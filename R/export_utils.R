# R/export_utils.R

#' @importFrom jsonlite toJSON
NULL

#' Export Documented Code Elements for Fine-Tuning LLMs
#'
#' @title Export Data for LLM Fine-Tuning
#' @description Formats extracted code elements and their LLM-generated documentation
#' into a JSONL (JSON Lines) file. This output is structured to be suitable for
#' fine-tuning language models, supporting different formats like chat-based or
#' prompt-completion pairs.
#'
#' @param documented_elements A list of documented code elements. Each element
#'        in the list is expected to be a sub-list containing at least the following
#'        character string fields: `type` (e.g., "function"), `name`,
#'        `signature` (function signature), `file_path` (relative path to the source file),
#'        `code_block` (the source code of the element), and `description`
#'        (the LLM-generated documentation for the element).
#' @param output_filepath Character string. The full path (including filename) where
#'        the output JSONL file will be saved.
#' @param format Character string. The desired output format. Currently supported
#'        formats are:
#'        \itemize{
#'          \item `"jsonl_chat"`: Formats each element as a sequence of system, user,
#'                and assistant messages suitable for chat-based model fine-tuning.
#'          \item `"jsonl_prompt_completion"`: Formats each element as a direct
#'                prompt (containing code details) and a completion (the documentation).
#'        }
#'        Default is `"jsonl_chat"`.
#' @param project_name Character string or NULL. Optional. The name of the project,
#'        which can be included in system prompts for the "jsonl_chat" format to
#'        provide context to the LLM. Default is `NULL`.
#' @param verbose Logical. If `TRUE`, prints status messages during the export process,
#'        including information about file creation and progress. Default is `TRUE`.
#'
#' @return Invisible `NULL`. The function writes data to a file as a side effect.
#'         It will stop with an error if critical issues occur (e.g., `jsonlite`
#'         package not found, file writing errors).
#'
#' @details
#' - The function first checks if the `jsonlite` package is installed, as it's
#'   required for JSON serialization.
#' - It creates the output directory if it doesn't already exist.
#' - For each element in `documented_elements`, it constructs a JSON object
#'   according to the specified `format` and writes it as a new line in the
#'   `output_filepath`.
#' - If an element is missing required fields for the chosen format, it's skipped,
#'   and a warning is issued if `verbose` is `TRUE`.
#' - File connections are managed carefully using `on.exit` and `tryCatch` with a
#'   `finally` block to ensure they are closed.
#'
#' @examples
#' \dontrun{
#' # Sample documented elements (usually generated by other functions)
#' elements <- list(
#'   list(
#'     type = "function", name = "my_func", signature = "(x, y)",
#'     file_path = "R/utils.R", code_block = "my_func <- function(x, y) { x + y }",
#'     description = "This function adds two numbers."
#'   ),
#'   list(
#'     type = "function", name = "another_func", signature = "()",
#'     file_path = "R/core.R", code_block = "another_func <- function() { print('Hello') }",
#'     description = "This function prints a greeting."
#'   )
#' )
#'
#' # Export in "jsonl_chat" format
#' # export_for_finetuning(
#' #   documented_elements = elements,
#' #   output_filepath = "output/finetuning_chat_data.jsonl",
#' #   format = "jsonl_chat",
#' #   project_name = "MyTestProject",
#' #   verbose = TRUE
#' # )
#'
#' # Export in "jsonl_prompt_completion" format
#' # export_for_finetuning(
#' #   documented_elements = elements,
#' #   output_filepath = "output/finetuning_prompt_data.jsonl",
#' #   format = "jsonl_prompt_completion",
#' #   verbose = TRUE
#' # )
#' }
#' @export
export_for_finetuning <- function(
    documented_elements,
    output_filepath,
    format = "jsonl_chat",
    project_name = NULL,
    verbose = TRUE
) {

  if (!requireNamespace("jsonlite", quietly = TRUE)) {
    stop("The 'jsonlite' package is required but not installed. Please install it.")
  }

  if (is.null(documented_elements) || length(documented_elements) == 0) {
    if (verbose) cat("No documented elements provided. Nothing to export.\n")
    return(invisible(NULL))
  }

  output_dir <- dirname(output_filepath)
  if (!dir.exists(output_dir)) {
    if (verbose) cat(paste("Creating output directory:", output_dir, "\n"))
    dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)
  }

  con <- NULL

  tryCatch({
    if (format == "jsonl_chat") {
      if (verbose) cat(paste0("Opening file for writing in 'jsonl_chat' format: ", output_filepath, "\n"))
      con <- file(output_filepath, "w", encoding = "UTF-8")
      on.exit({
        if (!is.null(con) && isOpen(con)) {
          if (verbose) cat("Closing file connection (on.exit)...\n")
          close(con)
        }
      }, add = TRUE)

      processed_count <- 0
      for (i in seq_along(documented_elements)) {
        element <- documented_elements[[i]]

        required_fields <- c("type", "name", "signature", "file_path", "code_block", "description")
        missing_fields <- setdiff(required_fields, names(element))
        if (length(missing_fields) > 0) {
          if (verbose) {
            warning(paste0("Skipping element #", i, " (name: '", element$name %||% "NA",
                           "') due to missing fields: ", paste(missing_fields, collapse = ", "), "\n"))
          }
          next
        }

        system_prompt_content <- paste0(
          "You are an expert R programming assistant",
          if (!is.null(project_name) && nzchar(project_name)) paste0(" for the project '", project_name, "'") else "",
          ". Explain the following R code accurately and concisely."
        )

        user_prompt_content <- paste0(
          "Explain the R ", element$type, " named `", element$name,
          "` with signature `", element$name, element$signature,
          "` found in file `", element$file_path,
          "`. Code:\n```r\n",
          paste(element$code_block, collapse = "\n"), "\n```"
        )

        assistant_content <- element$description %||% ""

        json_data <- list(
          messages = list(
            list(role = "system", content = system_prompt_content),
            list(role = "user", content = user_prompt_content),
            list(role = "assistant", content = assistant_content)
          )
        )

        json_string <- jsonlite::toJSON(json_data, auto_unbox = TRUE, pretty = FALSE)
        writeLines(json_string, con)
        processed_count <- processed_count + 1
      }
      if (verbose) cat(paste("Successfully exported", processed_count, "elements to:", output_filepath, "\n"))

    } else if (format == "jsonl_prompt_completion") {
      if (verbose) cat(paste0("Opening file for writing in 'jsonl_prompt_completion' format: ", output_filepath, "\n"))
      con <- file(output_filepath, "w", encoding = "UTF-8")
      on.exit({
        if (!is.null(con) && isOpen(con)) {
          if (verbose) cat("Closing file connection (on.exit)...\n")
          close(con)
        }
      }, add = TRUE)

      processed_count <- 0
      for (i in seq_along(documented_elements)) {
        element <- documented_elements[[i]]

        required_fields <- c("type", "name", "code_block", "description")
        missing_fields <- setdiff(required_fields, names(element))
        if (length(missing_fields) > 0) {
          if (verbose) {
            warning(paste0("Skipping element #", i, " (name: '", element$name %||% "NA",
                           "') for prompt_completion due to missing fields: ", paste(missing_fields, collapse = ", "), "\n"))
          }
          next
        }

        prompt_content <- paste0(
          "Explain the R ", element$type, " named `", element$name, "`.",
          if (!is.null(element$signature) && nzchar(element$signature)) paste0(" Signature: `", element$name, element$signature, "`.") else "",
          if (!is.null(element$file_path) && nzchar(element$file_path)) paste0(" File: `", element$file_path, "`.") else "",
          "\nCode:\n```r\n",
          paste(element$code_block, collapse = "\n"), "\n```\n\nExplanation:"
        )

        completion_content <- element$description %||% ""

        json_data <- list(
          prompt = prompt_content,
          completion = completion_content
        )

        json_string <- jsonlite::toJSON(json_data, auto_unbox = TRUE, pretty = FALSE)
        writeLines(json_string, con)
        processed_count <- processed_count + 1
      }
      if (verbose) cat(paste("Successfully exported", processed_count, "elements to:", output_filepath, "\n"))

    } else {
      warning(paste("Invalid export format specified:", format,
                    ". Supported formats are 'jsonl_chat' and 'jsonl_prompt_completion'. No file written."))
    }
  }, error = function(e) {
    if (verbose) cat(paste("Error during export:", e$message, "\n"))
    if (!is.null(con) && isOpen(con)) {
      close(con)
      con <- NULL
    }
    stop(e)
  }, finally = {
    if (!is.null(con) && isOpen(con)) {
      if (verbose) cat("Closing file connection (finally block)...\n")
      close(con)
    }
  })

  return(invisible(NULL))
}
